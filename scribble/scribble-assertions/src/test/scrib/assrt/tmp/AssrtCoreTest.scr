//$ bin/scribblec-assrt.sh -ip scribble-assertions/src/test/scrib/ -d scribble-assertions/src/test/scrib/ scribble-assertions/src/test/scrib/assrt/tmp/AssrtCoreTest.scr -fair -assrt -z3 -batch -modelpng Proto1 Proto1.png -fsmpng Proto1 A Proto1_A.png -fsmpng Proto1 B Proto1_B.png



// http://sandbox.kidstrythisathome.com/erdos/




// FIXME: debug printing for assertion passes

// FIXME: distinguish branches where "not guaranteed safe" vs "impossible"



// unary choice: 
//   pre: forall (lhs)
//   forall lhs => (exists rhs) -- point is rhs may use vars in lhs
//   exists (lhs /\ rhs)
// -- forall [ (lhs /\ (lhs => (exists rhs))) => exists (lhs /\ rhs) ] -- ?
// -- forall [ lhs /\ (lhs => (exists rhs))) ] => forall [ exists (lhs /\ rhs) ] -- ?
/*
(declare-fun lhs (Int Int) Bool)
(declare-fun rhs (Int Int Int Int) Bool)
(assert (forall ((x1 Int) (y1 Int)) (lhs x1 y1)))
(assert  (=>   
  (forall ((x1 Int) (y1 Int)) (and (lhs x1 y1) (=> (lhs x1 y1) (exists ((x2 Int) (y2 Int)) (rhs x1 y1 x2 y2)))))
  (forall ((x1 Int) (y1 Int)) (exists ((x2 Int) (y2 Int)) (and (lhs x1 y1) (rhs x1 y1 x2 y2))))
))
(check-sat)  // FIXME: check negation is unsat
(exit)  
*/


// FIXME: statevar decl invariants
// muZ for fixed points -- recursive statevar updates? -- http://rise4fun.com/Z3/tutorial/fixedpoints

// - assertion validation
// - receive assertions -- why receive assertions?  should WF imply receive assertions always true?
// - explicit connections

// .. checking assertions sender side only is important for services -- maybe complex/expensive operation, point is to ask service to do it, so must be the service only to check it also

//	.. rename connect to request
//	.. refactor a GConnectionAction (cf. LConnectionAction)

// .. need to update SubprotocolSig and "cycle" detection for protocoldecl/do annots? -- protocol inlining/unfolding with annots/assertions
// .. how about "syntactic" reachability check with protocoldecl/do annots?

// - recursion annotations
// - port forwarding annotations/assertions
// - arrays? -- cf. dependent types for array/list lengths -- https://www.reddit.com/r/fsharp/comments/28bbsr/faking_dependent_types_in_f/

// redo inlining/unfolding via model building? role/param/assert all in model states?

// FIXME: batching optimisation contains redundancy? -- all formulae are standalone (full "trace histories"), but maybe not necessary if batching?




// unsat is a preserving safety error, op sem should freeze on an unsat choice -- but otherwise should allow branch selection, even if not "strictly" assert-prog
// assert-prog is a progress guarantee, but not a preserving safety error -- because assert-prog says there isn't a guaranteed option to proceed, but by op sem we can take any non-unsat case anyway

// try: simply compact all clauses with old vars -- since old var value is "lost", can never eval the clause anyway? -- model corresponds to the way syntactic var substitution works?
//		more explicitly, it corresponds to a scoping mechanism derived from syntactic source protocol that determines what vars can be "used" as constraints at protocol points?
// or continue-specific ("statevar update" of action) GC of clauses with old vars?

// F is a set of constraints that are true so far, but need to record to check more upcoming constraints
// once any clause has an "old var", can delete the clause because model is that we don't have old var value anymore so can't evaluate the constraint
// arguing about the "value" doesn't really make sense here, because doing forall anyway
// it's more like, "old var" ever won't be "used" in an upcoming constraint -- at least not "directly", but also not "indirectly"? -- also not "indrectly" because of "temporal ordering" given by syntax: e.g., x->y->z->loop, if x becomes old, then any upcoming use of y must also occur after y becomes old




// merging DONE
// - coreconfig flags Map->Set -- done: refactored separate CoreArgs and CoreFlags
// - make uniform orig/new assrt node parsing/astfactor (refactor parser mixed new ast types with old token types) -- refactor new ast types to fully subsume old ones (e.g., getChildren) -- done
// - fix new parser reflection in tree adaptor (no common interface for "module" top-level method) -- done
// - refactor astfactoryimpl token constants to parser (and refactor ast/delfactoryimpl to scribble-ast) -- done: ScribAntlrTokens

// merging TODO
// - FIXME TODO prune unsat recursive choice cases after selecting a case, good.extensions.assrtcore.safety.unsat.AssrtCoreTest36
// - FIXME: when inlining f/w rec state args, inline constant vars directly (analogous to cont-rec constant inlining) -- make an isConstant method for types/Formula -- cf. `y=x`, good.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08f
// - factor out Protocol<K, N, Type> above existing (Seq)Protocol, AssrtCoreProtocol under the former -- or replace inheritance by deleg? (see later)
// - CHECKME: GTypeTranslation syntax exception (JUnit harness)
// - rename "new" factory methods? (easily confused with new expr)  centralise?
// - rename AssrtCore to Core? -- implement "strict" mode via translator?
	// - proto params not supported -- CHECKME: mixing rec/continue with protodecl/do
// - refactor exceptions to main packages
// - refactor -inline via temporary directory/file
// - check super.addScribChildren pattern
// - consider del's over ast subclassing for ext's like assrt -- alternatively, extend base's, and subclass for G/L (instead of extending G/L)
// - check genereal overrides, return super types where better -- @deprecate runtimeexception overrides? e.g, reconstruct
// - check Assrt NameDisamb/checkAnnot passes
// - rename Assertions.g related stuff with Annot prefix
// - disamb annot statevars (etc?) to qualified names, avoid "rename" issues (cf. AssrtCoreSConfig)
// - maybe move init config factory from util to builder?
// - refactor model (safety) error checking operations into EFsm? (need to pass queues) 
// - refactor common formula building for error checks in AssrtCoreSConfig

// later:
// - fix duplicate proto decl name check
// - refactor modulecontext building, move dup vis name checks out (drop scribexception)
// - try var type inference
// - refactor namedisamb functionality
// - annot var lin modifier?  etc?
// - consider refactoring Core/Config/Context to be more neutral of G/LProtocol (use Protocol super)
//		- consider refactoring base as an ext outside of core
//		- separate core (seq) from "classic"? -- maybe add Seq as an "ext" of classic? (currently deprecating a lot of core for classic, but should be the other way round)
//		- consider replacing some inheritance by delegation/nesting, e.g., LProjection/Protocol (cf. SModel/SGraph)
//		- replace nullables by Optional
// - refactor Kinds as types only?  or values needed for serialization?
// - fix UnaryPayElem generic casts (and AssrtAnnotDataElem)
// - standardise EFSM/model format -- should contain data type info (e.g., for STP) -- should make a decl language for FSM module members, share imports with protos


// - tricky: state vars get "wildcarded" ("_" prefix), but "old" knowledge may remain (and be used) in F, e.g., good.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08f
// - assertions specify "knowledge" communication, need to duplicate to multiple peers as necessary -- e.g., assertions on state vars without any payloads
// - "static" assertions at scribble level (design time), vs. actual "dynamic" assertions at process level (run time) -- consider gradual-ness -- e.g., x>1, followed by x>0 or x>2 
// - rec-continue state args on continue edge only, tricky for duality in MP situations (e.g., A->B.A->C.X<123>, consider A/B projections)





/*
- model checking: uniform validation for integrating different MPST features
- assertions only "reduce" behaviours? true-only assertions
- basic model based on "types" -- so 1-bounded finite
- how to introduce semantics of assertions into model and stay finite?
-- because assertions introduce values -- arithmetic
- have to leverage syntactic characteristics to support the model checking
-- all about recursion (including action assertions, not only statevars), managing finiteness
-- assertions as syntactic terms (syntactically equal terms have same meaning), CNF sets allows "syntactic"-closure on constraints -- no hardcoded two-unfolding
-- "old actvar" renaming for recursively "shadowed" vars -- following syntactic recursion substitution -- cf. fresh vars
--- multiparty old actvar renaming based on message flow
--- then compacting -- i.e., syntactic term GC hack
-- then the "inductive" step, given by old statvar renaming becoming forall
--- very conservative -- restore "precision" by recursion assertions as "loop invariants"
- so model checked errors: unknownvar (HS), assert-prog (TS?), sat (TS?), recursion-assert
*/

module assrt.tmp.AssrtCoreTest;


/*type <dotnet> "System.UInt32" from "..." as int;
type <dotnet> "System.String" from "..." as String;
type <dotnet> "..." from "..." as bool;*/

// TODO: refactor "primitives",  cf. AssrtCoreGTypeTranslator.parsePayload, AssrtAmbigVarFormula.disamb, AssrtCoreSConfg.getAssVars, AssrtForallFormula.toSmt2Sort
type <fstar> "int" from "..." as int;
//type <fstar> "string" from "..." as string;  // N.B. Z3 needs String
type <fstar> "string" from "..." as String;



// TODO HERE
// - fix expression parsing, e.g., parentheses
// - rec syntax -- can then do all tests 
// - transitive V/R GC, also F -- actually necessary?
//done
// - batch mode
//
// done
// - do rec assert check using FSM edges, not message -- difference is statevars


//- statevar/arg syntax
//- startvar usages? parameterised protocols, loop counting
//- conflict between unsat checking, state vars (init values, constants) and recursion -- "strict" vs. potential unsat
//- theorem: no assertion prog error at run-time -- no unsat theorem? -- prog is sound, unsat is complete?



// - fix syntax -- TODO: deprecate AssrtStateVarAnnotNode for an intermediary CommonTree
// - deprecate "constant propagation" -- prevents loops counting or any example where assertion not valid now under constant but could be later -- now: restored


global protocol Proto1(role A, role B) {
	1() from A to B;
}




/*
global protocol Proto1(role A, role B) {  // Cf. OnlineWallet
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);  @'<b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  @'<balance:=0, overdraft:=0> balance>=(0-overdraft) && overdraft>=0' {
	1(x:int) from A to B;  @'0<=x && x<=(balance+overdraft)'
}
//*/

/*
global protocol Proto1(role A, role B) {
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);  @'<b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  @'<balance:=0, overdraft:=0> balance>=(0-overdraft) && overdraft>=0' {
	choice at A {
		1(x:int) from A to B;  @'0<x && x<=(balance+overdraft)'
	} or {
		2() from A to B;
	}
}
//*/

/*
global protocol Proto1(role A, role B) {
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);    @'<b, 100>'
}
//aux global protocol Proto1Aux(role A, role B)  @'<balance=0, overdraft=0> balance>=(0-overdraft) && overdraft>=0' {
aux global protocol Proto1Aux(role A, role B)  @'<balance:B=0, overdraft:B=0> balance>=(0-overdraft) && overdraft>=0' {
	choice at A {
		1(x:int) from A to B;  @'0<x && x<=(balance+overdraft)'
		do Proto1Aux(A, B);    @'<balance-x, overdraft>'
	} or {
		2() from A to B;
	}
}
//*/

/*
global protocol Proto1(role A, role B) {  // Cf. OnlineWallet
	0(b:int) from B to A;  @'b>=-100'
	do Proto1Aux(A, B);    @'<b+100, b, 100>'
}
aux global protocol Proto1Aux(role A, role B)  // Testing exist quant phantom statevars in state assertions (allow w.r.t. C)
			@'<allow:A=100, balance:B=0, overdraft:B=100> allow=balance+overdraft && balance>=(0-overdraft) && overdraft>=0' {

	choice at A {
		1(x:int) from A to B;  @'0<x && x<=allow'
		do Proto1Aux(A, B);    @'<allow-x, balance-x, overdraft>'
	} or {
		2() from A to B;
	}
}
//*/





/*
global protocol Proto1(role A, role B, role C) {  // Bad
	1(x:int) from A to B;
	2(y:int) from C to B; @'y>x'  // CHECKME: x is phantom for C, despite no causality between A and C
	// ^but caught by async model checking, because K update is *post* condition of send
}
//*/






/*
global protocol Proto1(role A, role B, role C)
{
	//start(n0:int, t0:int) from A to B;  @'(0<=n0 && n0<100) && 0<t0'
	//do Aux(A, B, C);  @'<n0, t0>'
	do Aux(A, B, C);  @'<0, 1>'
}

aux global protocol Aux(role A, role B, role C) @'<n:B=0, t:B=1> (0 <= n && n < 100) && 0 < t'
//aux global protocol Aux(role A, role B, role C) @'B<n:int=0 (0 <= n && n < 100)> B<t:int=0 (0 < t)>'
//aux global protocol Aux(role A, role B, role C) @'B<n:int{0 <= n && n < 100}=0, t:int{0 < t}=0>'
{
	guess(x:int) from C to B;  @'0<=x && x<100'  // Next guess by C
	choice at B
	{
		higher() from B to C;  @'n>x && t>1'    
		higher() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{
		foo() from B to C;
		foo() from B to A;  // Testing phantom assertion edges
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	start(n0:int, t0:int) from A to B;  @'(0<=n0 && n0<100) && 0<t0'
	do Aux(A, B, C);  @'<n0, t0>'
}

aux global protocol Aux(role A, role B, role C) @'<n:B=0, t:B=1> (0 <= n && n < 100) && 0 < t'
//aux global protocol Aux(role A, role B, role C) @'B<n:int=0 (0 <= n && n < 100)> B<t:int=0 (0 < t)>'
//aux global protocol Aux(role A, role B, role C) @'B<n:int{0 <= n && n < 100}=0, t:int{0 < t}=0>'
{
	guess(x:int) from C to B;  @'0<=x && x<100'  // Next guess by C
	choice at B
	{
		higher() from B to C;  @'n>x && t>1'    
		higher() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{ 
		win() from B to C;  @'n=x'   
		lose() from B to A;
	}
	or
	{ 
		lower() from B to C;  @'n<x && t>1'
		lower() from B to A;
		do Aux(A, B, C);  @'<n, t-1>'
	}
	or
	{
		lose() from B to C;  @'(!(n=x)) && t=1'
		win() from B to A;
	}      
}
//*/





/*
global protocol OnlineWallet(role S, role C, role A) {
 login(id: String, pw: String) from C to A;
 choice at A {
   login_ok() from A to C;
   login_ok() from A to S;
   account(balance: int, overdraft: int) from S to C; @"balance>=0 && overdraft>=0"
   do Authenticated(S, C); @"<balance + overdraft>"
 } or {
   login_fail(error: String) from A to C;
   login_fail() from A to S;
 }
}

aux global protocol Authenticated(role S, role C) @"<allowance:C=0> allowance>=0" {
 choice at C {
   pay(payee: String, amount: int) from C to S; @"amount<=allowance"
   account(newbalance: int, newoverdraft: int) from S to C; @"newbalance>=0 && newoverdraft>=0"
   do Authenticated(S, C); @"<newbalance + newoverdraft>"
 } or {
   quit() from C to S;
 }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;  @'0<=x && x<100'  // Added this refinement
  choice at B {
    higher() from B to C;    @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);   @'<n1, t1-1>'
  } or {
    win() from B to C;       @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;      //@'(!(n1=x)) && t1=1'  // FIXME: ! precedence
                             @'((n1<x || n1>x) && t1=1)'
    win() from B to A;
  } or {
    lower() from B to C;     @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);   @'<n1, t1-1>'
  }
}
//*/


/*
global protocol DbC(role Buyer, role Seller, role Bank) @"<pvo:=100>"
{
  offer(vo:int) from Buyer to Seller; @"vo >= 100"
  choice at Seller {
    hag() from Seller to Buyer; @"vo > pvo"
    do DbC(Buyer, Seller, Bank); @"<vo>"
  } or {
    ok() from Seller to Buyer;
    payment(vp:int) from Buyer to Bank; @"vo = vp"
    ack(va:bool) from Bank to Seller;
  }
}
//*/


/*
global protocol Proto1(role A, role B) @'<xA:A=1, xB:B=1>' {
	1() from A to B;
	do Proto1(A, B); @'<xA, xB>'
}
//*/


/*
global protocol Proto1(role A, role B) @'<xA:A=1, xB:B=1>' {  
// Maybe don't need or shouldn't have "sync'd" state vars, i.e., keep all distributed (distinct var names)
// Rely on explicit payload vars -- comm'd will be know anyway, and can manually assign to statevar locally
// And since assertion depends on statevars, means statevar annots are "localised" one role per rec
// Basically, can nest recs anyway for multiple roles
	1() from A to B;
	do Proto1(A, B); @'<xA, xB>'
}
//*/


/*
global protocol Proto1(role A, role B) {  
	1(x:int) from A to B;
	do Proto1(A, B); @'<x, x>'  // TODO: fix error
	do Proto1Aux(A, B); @'<x, x>'
}

aux global protocol Proto1Aux(role A, role B) @'<xA:A=1, xB:B=1>' {  // FIXME TODO drop init sexprs for aux statevars
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B, role C) {  
	1(x:int) from A to B;  @'x>0'
	do Proto1Aux(A, B, C); @'<x, x>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<xA:A=1, xB:B=1> xB>0' {
	2() from B to A;
	2() from B to C;
}
//*/


/*
global protocol Proto1(role A, role B) @'<x:=1, y:=2> x>1 || y>1'  
// Cannot do "fine-grained projection" of assertions onto located statevars
// TODO add bad test
{
	choice at A
	{
		1() from A to B; @'x>1'
	}
	or 
	{
		2() from A to B;
	}	
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  1(x:int) from A to B;    @'x>5'
  do Proto1Aux(A, B, C);   @'<x>'  // FIXME TODO: check x is known by B (target located statevar)
}

aux global protocol Proto1Aux(role A, role B, role C) @'<x1:B=1> x1>0' {
  2() from C to B;  // TODO: add bad test -- x1 globally inlined to x is incorrect for C (C doesn't know x)
  3() from C to A;  //@'x>0 && x<2'  // Cannot have mixed init of statevar, e.g., from message for located, from default for nonlocated, inconsistent -- quantify? (phantom?)  // TODO add bad test
}
//*/


/*
global protocol Proto1(role A, role B)
{
	//1() from A to B;
	do Proto1Aux(A, B); @'<2>'
}

aux global protocol Proto1Aux(role A, role B) @"<y:=1>"  // FIXME: batch is failing, but default is passing -- no: it's because the "new" ass-unsat works this way (cf. AssrtCoreSModel)
{
	choice at B
	{
		2() from B to A; //@'y>1'
	  do Proto1Aux(A, B); @'<y-1>'
	}
	or
	{
	  3() from B to A; @'y<=1'  // initial (i.e., original) ass-unsat fails because y:=1
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;
  choice at B {
    higher() from B to C;   @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);  @'<n1, t1-1>'
  } or {
    win() from B to C;      @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;     @'(!(n1=x)) && t1=1'  // FIXME: ! precedence
    win() from B to A;
  } or {
    lower() from B to C;    @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);  @'<n1, t1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;  @'0<=n && n<100'
  limit(t:int) from A to B;  @'t>0'
  do Proto1Aux(A, B, C);     @'<n, n, t>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<nA:A=0, n1:B=0, t1:B=1> t1>0' {
  guess(x:int) from C to B;
  guess() from C to A;
  choice at B {
    higher() from B to C;   @'n1>x && t1>1'
    higher() from B to A;
    do Proto1Aux(A, B, C);  @'<nA, n1, t1-1>'
  } or {
    win() from B to C;      @'n1=x'
    lose() from B to A;
  } or {
    lose() from B to C;     @'!(n1=x) && t1=1'
    win() from B to A;
  } or {
    lower() from B to C;    @'n1<x && t1>1'
    lower() from B to A;
    do Proto1Aux(A, B, C);  @'<nA, n1, t1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B, role C) {
  start(n:int) from A to B;     @'0<=n && n<100'
  limit(t:int) from A to B;     @'t>0'
  guess(x:int) from C to B;
  do Proto1Aux(A, B, C);        @'<n, t, x, x>'
}

aux global protocol Proto1Aux(role A, role B, role C) 
                                @'<n1:B=0, t1:B=0, xB:B=0, xC:C=0> t1>=0' {
  choice at B {
    higher() from B to C;       @'n1>xB && t1>0'
    higher() from B to A;
    guess(x2:int) from C to B;  @'x2>xC'
    do Proto1Aux(A, B, C);      @'<n1, t1-1, x2, x2>'
  } or {
    win() from B to C;          @'n1=xB'
    lose() from B to A;
  } or {
    lose() from B to C;         @'(!(n1=xB)) && t1=0'  // FIXME: ! precedence
    win() from B to A;
  } or {
    lower() from B to C;        @'n1<xB && t1>0'
    lower() from B to A;
    guess(x3:int) from C to B;  @'x3<xC'
    do Proto1Aux(A, B, C);      @'<n1, t1-1, x3, x3>'
  }
}
//*/


/*  // TODO z3 bitvec 
global protocol Proto1(role A, role B) @'<x:=0>' {
	1(y:int) from A to B;  @'...'
}
*/



































/*
global protocol Proto1(role A, role B, role C) {
  num(x:int) from A to B;
  limit(z:int) from A to B;
  do Proto1Aux(A, B, C); @'<x, z>'
}

aux global protocol Proto1Aux(role A, role B, role C) @'<x1:=0, z1:=0>' {
  guess(y:int) from C to B;
  choice at B {
    toohigh() from B to C;     @'y>x1'
    conthigh() from B to A;
    do Proto1Aux(A, B, C);  @'<x1, z1-1>'
  } or {
    win() from B to C;         @'y=x1 && z1>0'
    lose() from B to A;
  } or {
    lose() from B to C;        @'z1<=0'
    win() from B to A;
  } or {
    toolow() from B to C;      @'y<x1'
    contlow() from B to A;
    do Proto1Aux(A, B, C);  @'<x1,z1-1>'
  }
}
//*/


/*
global protocol Proto1(role A, role B) @"<y:=0, x:=50>"
{
	choice at A
	{
		1() from A to B;
		do Proto1(A, B); @"<y, x+1>"
	}
	or
	{
		i2() from A to B;
		do Proto1(A, B); @"<y, x-1>"
	}
}
//*/

/*
global protocol Proto1(role A, role B, role C)
{
	1() from A to B;
	do Proto1Aux(B, C);
}

aux global protocol Proto1Aux(role B, role C)
{
	2() from C to B;
  choice at B
  {
  	3() from B to C;
  	do Proto1Aux(B, C);
  }
  or
  {
  	4() from B to C;
  }
}
//*/


/*
global protocol Proto1(role A, role B) @'<x:=0>' {
	1(x1:int) from A to B;  @'x1>=x'
	do Proto1Aux(A, B);  @'<x1>'
}

aux global protocol Proto1Aux(role A, role B) @'<y:=0> y>=0' {
//aux global protocol Proto1Aux(role A, role B) @'<y:=0> y>=1' {
	2(y1:int) from B to A;  @'y1>y'
}
//*/


// - rename intvar
// - remove disamb






/*
global protocol Proto1(role A, role B, role C) @'<x:=0>' {
	choice at A {
		1() from A to B;  @'x=0'	
		1() from B to C;	@'x=0'  // Shows "global statevar" exprs must be statically fixed (not locally/dynamically set)
	} or {
		2() from A to B;  //@'x=1'	
		2() from B to C;	//@'x=1'
	}
}
//*/







/*  // Testing statevar WF -- init exprs (constants)
global protocol Proto1(role A, role B) @'<x:=0>' {
	1() from A to B;  @'x=0'
	//1() from A to B;  @'x=1'  // Bad
}
//*/


/*  // Testing statevar WF -- loop counting
//global protocol Proto1(role A, role B) @'<x:=0>' {
//global protocol Proto1(role A, role B) @'<x:=0> x >= 0' {
global protocol Proto1(role A, role B) @'<x:=0> x >= 0 && x <= 5' {  // TODO: add tests
//global protocol Proto1(role A, role B) @'<x:=0> x >= 0 && x < 5' {  // Bad
	choice at A {
		1() from A to B;  @'x<5'
		do Proto1(A, B);  @'<x+1>'
	} or {
		2() from A to B;  @'x>=5'
		//2() from A to B;  @'x=5'  // CHECKME: not allowed, not assrt-prog for _x case
	}
}
//*/


/*  // Testing statevar WF -- loop counting
//global protocol Proto1(role A, role B) @'<x:=0>' {  // 2()@x>=5 not caught as unsat (without any statevar ass)
global protocol Proto1(role A, role B) @'<x:=0> x >= 0' {  // Bad (as intended)  // TODO: add tests
	choice at A {
		1() from A to B;  @'x<5'
		do Proto1(A, B);  @'<x-1>'
	} or {
		2() from A to B;  @'x>=5'
	}
}
//*/



/* // Testing new unsat
global protocol Proto1(role A, role B) {
	choice at A {
		1() from A to B;
	} or {
		2() from A to B;  @'False'
	}
}
//*/


/*  // Testing new unsat
global protocol Proto1(role A, role B) @'<x:=0>' {
	choice at A {
		1() from A to B;
		do Proto1(A, B);  @'<0>'  // Bad
		//do Proto1(A, B);  @'<1>'
	} or {
		2() from A to B;  @'x=1'
	}
}
//*/












/*
global protocol Proto1(role A, role B) @'<x:="123">' {
	//1() from A to B;
	1() from A to B; @'x = "123"'  // TODO: "internal" sort check?
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=122>" {
	1() from A to B; @"x < 123"  // CHECKME TODO: special case of "non-recursive" state vars? (no need to check assrt-prog with _x)
}
//*/


/*
global protocol OAuth (role C, role S, role A) {
 login(account: int) from S to C;
 do Auth(C, S, A); @"<0>"
}

//aux global protocol Auth (role C, role S, role A) @"<try:=0> try>=0 && try<=3" {
// password() from C to A;
// authed() from A to S;
//}

aux global protocol Auth (role C, role S, role A) //@"<try:=0> try>=0 && try<=3" {
                                                   @"<try:A=0> try>=0 && try<=3" {
 password(pwd: int) from C to A;
 choice at A {
   authed() from A to S;
   authed() from S to C;
 } or {
   again() from A to S; @"try<3"
   //again() from S to C;
   again() from S to C; //@"try<3"  // Cf. "global" statevars
   do Auth(C, S, A); @"<try+1>"
 } or {
   failure() from A to S; @"try=3"
   failure() from S to C;
 }
}
//*/


/*
global protocol Proto1(role A, role B) {
	//1(x: int) from A to B; @"x=123"
	1(x: String) from A to B; @"x='abc'"
	//2(y: int) from A to B; @"x=y"
	2(y: String) from A to B; @"x=y"
}
//*/

/* // FIXME: statevar syntax, sorts -- e.g., cf. AssrtCore.getInlined, statevars
global protocol Proto2(role A, role B) { //@"<y:='def'>"
	//1(x: String) from A to B; @"x='123 def'"
	1(x: String) from A to B; @'x="abc"'
	//1(x: int) from A to B; @"x=123"
}
//*/



/*
// A=3,  B=12345
global protocol Proto1(role A, role B) @"<x_A:=1> x_A>=0" {

	0(z:int) from A to B;	@"z=x_A"// && z=y_B"
	
	do Proto1Aux(A, B);  @"<z, z>"
}
	
//global protocol Proto1Aux(role A, role B) @"px_A>=0 && px_B>=0" { }

global protocol Proto1Aux(role A, role B) @"<x_A:=*, y_B:=*> x_A>=0 && y_B>=0" {

	choice at A
	{
		1() from A to B; @"x_A<5"	
		3() from B to A; @"y_B<5"
		do Lock(A, B);  @"<x_A+1>"
	}
	or
	{
		2() from A to B; @"x_A>=5"	
	}
}
//*/


/*
global protocol Lock(role A, role B, role C)
{
	REQ () from A to B;
	REQ () from A to C;
	choice at B
	{
		ACK () from B to A;
		//foo () from B to C;
		choice at C
		{
			ACK () from C to A;
			REL () from A to B;
			REL () from A to C;
		}
		or
		{
			do Lock(C, A, B);
			//REQ () from C to A;
			//REQ () from C to B;
		}
	}
	or
	{
		do Lock(B, A, C); // should we set the initial clocks here?
	}
}
//*/


/*
choice at A
{
	1() from A to B;
	3() from B to C;  // C?B:3
}
or
{
	2() from A to B;
	4() from B to C;  // C?B:4
}
//*/


/*
global protocol Lock(role A, role B, role C)
{
	REQ (tsrab:int) from A to B;
	REQ (tsrac:int) from A to C; @"tsrac > tsrab"
	choice at B
	{
		ACK (tsaba:int) from B to A; @"tsaba >  tsrab"
		choice at C -> B
		{
			ACK (tsaca:int) from C to A; @"tsaca > tsrac"
			REL (tsreab:int) from A to B; @"tsreab > tsrab"
			REL (tsreac:int) from A to C; @"tsreac > tsrac"
		}
		or
		{
			//....
			do Lock(C, A, B);
		}
	}
	or
	{
		do Lock(B, A, C); // should we set the initial clocks here?
	}
}
//*/


/*
global protocol Proto1(role A, role B) 
		//@"<x:=3>"  // Bad
		@"<x:=3> x=3"
{
	1() from A to B; @"x=3"	
	do Proto1(A, B); @"<3>"
	//do Proto1(A, B); @"<4>"  // Bad
}
//*/


/*
global protocol Proto1(role A, role B) 
		//@"<x:=0> x>=0"
		@"<x:=0> x>0"  // Testing revised init-rec-assert check -- TODO: add test
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);  @"<123>"  // Testing f/w rec statevar expr endpoint graph building
			// An "encoding" of top-level statevar initialiser exprs
}

aux global protocol Proto1Aux(role A, role B)  @"<x:=0>"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B); @"<0>"  // Testing f/w rec statevar expr endpoint graph building
}

aux global protocol Proto1Aux(role A, role B) @"<x:=0>"
{
	choice at A
	{
		2() from A to B; @"x<5"
		do Proto1Aux(A, B); @"<x+1>"
	}	
	or
	{
		3() from A to B; @"x>=5"  
	}
}
//*/



/*
global protocol Proto1(role A, role B) @"<x:=0> x>=0"
{
	choice at A
	{
		1() from A to B; @"x<5"
		//do Proto1(A, B); @"<x+1>"
		//do Proto1(A, B); @"<x>"
		do Proto1(A, B); @"<x-1>"  // Bad -- TODO: add tests
	}	
	or
	{
		2() from A to B; @"x>=5"  
	}
}
//*/


/*
// testing "f/w rec" with a state assertion
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B); @"<0>"  // Testing f/w rec statevar expr endpoint graph building
}

aux global protocol Proto1Aux(role A, role B) 
		//@"<x:=0> x>5"  // TODO: add tests
		@"<x:=0> x>=0"
{
	2() from B to A;
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=0>"
{
	choice at A
	{
		1() from A to B; @"x<5"
		do Proto1(A, B); @"<x+1>"
	}	
	or
	{
		2() from A to B; @"x>=5"  
				// Testing unsat after deprecating state var init exprs and "constant propagation"
				// Original intuition was to model "base case" and "induction step", but this is incompatible with unsat checking + loop counting
				//@"x=5"  // Bad assrt-prog
	}
}
//*/


/*
global protocol Proto1(role A, role B) @"<x:=0> x>1"
{
	1() from A to B;
	//do Proto1(A, B);  @"<x-1>"  // Bad -- CHECKME: add tests?
	//do Proto1(A, B);  @"<x>" // OK
	do Proto1(A, B);  @"<x+1>"
}
//*/


























/*
global protocol Proto1(role A, role B) //@<x:="0">  //"arithmetic/boolean expr"
{
	0(y:int) from A to B;
	do Proto1Aux(A, B);
}

aux global protocol Proto1Aux(role A, role B)
{
	choice at A
	{
		1() from A to B;  @"y<=0"
		do Proto1Aux(A, B);  //@<"x">
	}
	or
	{
		2() from A to B;  @"y>0"
	}
}
//*/



/* // CHECKME: pre vs. post assertions?  corresponds to static vs. dynamic?  cf. Eiffel
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B; @"x<3"
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=2"  // FIXME: unsat -- solely due to constant prop?
	}
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B;
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=5"  // FIXME: unsat -- solely due to constant prop?
	}
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="0">
{
	choice at A
	{
		1() from A to B;	@"x<5"  
		do Proto1(A, B); @<"x+1">
	}
	or
	{
		2() from A to B;	 @"x>=5"  // FIXME: unsat on first loop -- solely due to constant prop?
			 // this unsat is also "inconsistent" with the fact that having only x<=5 is also "potentially" unsat after some loops
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	(x: int) from A to B;  @"(!!True)" 
	//2(y:int) from A to B; @"((y=2) && (y=(4+1)))"
	//(x: int) from A to B;  @"x = 1 + 3 - 4 *5"  // TODO add syntax tests (op precedence and assoc)
	//(y: int) from B to A;  @"y<0 || y > 1 && y>2"
}
//*/


/* // CHECKME -- [assrt-core] Cannot project 
global protocol Proto1(role A, role B, role R)
{
	() from A to R;
	do Loop(A, B);
}

aux global protocol Loop(role A, role B)
{
	Res(b2:int) from A to B;
	choice at A
	{
		SecOut() from A to B;  @"b2>0"
	}
	or
	{
		SecIn() from A to B;   @"b2<=0"
		do Loop(A, B);
	}
}
//onto R: cannot merge unguarded rec vars
//*/






/* // good.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest37
global protocol Proto1(role A, role B) @<x:="1", y:="2"> "x>=1 && y>x"
{
	3(z1: int) from A to B;	 @"z1=x+y"
	do Proto1(A, B);         @<"y", "z1">  
			// Testing `y` vs `y1` state arg -- differentiating V update between general renaming (x=_y) and "constant propagation" (x=2) special case
			// Cf. Fib -- also AssrtCoreTest08f/g
}
//*/


/* // AssrtCoreTest08f
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing ass in F, independent of pay 
	do Proto2(A, B); @<"x">
}

// Not aux
global protocol Proto2(role A, role B) @<y:="4">
{
	1() from A to B; @"(y>2)"
	do Proto2(A, B); @<"y">
}
//*/











/* // good.extensions.assrtcore.safety.unsat.AssrtCoreTest35
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{
		Bes(b2:int) from B to A;
		choice at A
		{
			SecOut() from A to C;  @"b2>0"
			do Proto1(A, B, C);
		}
		or
		{
			SecIn() from A to C;   @"b2<=0"
			do Proto1(A, B, C);
		}
	}
}
//*/


/*  // TODO good.extensions.assrtcore.safety.unsat.AssrtCoreTest36
global protocol Proto1(role A, role B)
{
	Res(b2:int) from A to B;
	do Loop(A,B);
}

aux global protocol Loop(role A, role B)
{
	choice at A
	{
		SecOut() from A to B;  @"b2>0"
	}
	or
	{
		SecIn() from A to B;   @"b2<=0"  // TODO FIXME: "locked in" recursive choice, do by pruning unsat recursive choice cases?  Cf. unfair transform
				// FIXME: b2>0 unsat after doing one b2<=0 (i.e., b2<=0&&b2>0 unsat)
				// drop unsat?  or somehow only do unsat for payload vars? (not state vars) -- or "weaken" unsat to not use V and implicitly forall statevars
				// or drop "constant propagation"?  or "init values"?
		do Loop(A, B);
	}
}
//*/



























/* Test035 -- Test037 */

/*
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing, V update also needs to GC F -- TODO add test
	do Proto1(A, B); @<"2">
}
//*/


/*
global protocol Proto1(role A, role B) @<x:="3">
{
	1() from A to B; @"(x>2)"  // Testing ass in F, independent of pay 
	do Proto2(A, B); @<"x">
}

// Not aux
global protocol Proto2(role A, role B) @<y:="4">
{
	1() from A to B; @"(y>2)"
	//do Proto1(A, B); @<"y">
	do Proto2(A, B); @<"y">
}
//*/


/*// Testing (removal of) state args from messages, cf. duality between A and B (w.r.t. <1>)
global protocol Proto1(role A, role B, role C) @<x := "0">
{
	1() from A to B;
	2() from A to C;
	do Proto1(A, B, C); @<"1">  // TODO: add test
}
//*/














/*  // Fibs -- AssrtCoreTest4.scr
//global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>x"  // Bad (e.g., x=y=1)
global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>=x"
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=x1+y1"
	do Proto1(A, B);         @<"y", "z1">
}
//*/

/* 
global protocol Proto1(role A, role B) @<x:="1", y:="2"> "x>=1 && y>x"
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=x1+y1"
	do Proto1(A, B);         @<"y", "z1">
}
//*/

/*
global protocol Proto1(role A, role B) @<x:="0", y:="1", z:="1"> "(x>=0 && y>=x) && z=x+y"  // FIXME: parentheses
{
	1(x1: int) from A to B;	 @"x1=x"
	2(y1: int) from A to B;	 @"y1=y"
	3(z1: int) from B to A;	 @"z1=z"
	do Proto1(A, B);         @<"y1", "z1", "y1+z1">
}
//*/

/*
global protocol Proto1(role A, role B) @<x:="0", y:="1"> "x>=0 && y>=x"
{
	choice at A
	{
		1(x1: int) from A to B;	 @"x1=x"
		2(y1: int) from A to B;	 @"y1=y"
		3(z1: int) from B to A;	 @"z1=x1+y1"
		do Proto1(A, B);         @<"y", "z1">
	}
	or
	{
		4() from A to B;
	}
}
//*/













/* Test032 -- Test034 */

/* // Testing rec assertion
global protocol Proto1(role A, role B) @<x:="0"> "x>=0"
{
	1(y: int) from A to B; @"y>0"  // Comment annotation is bad
	do Proto1(A, B); @<"y">
}
//*/


/* // Testing rec assertion
global protocol Proto1(role A, role B) @<x:="0"> "x>=0"
{
	1(y: int) from A to B; @"y>x"  // Comment annotation is bad
	do Proto1(A, B); @<"y">
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @"x>=0"
	2(y: int) from B to C;  @"y=x && y>=0"  // Knowledge about x/y "told" to C
	//2(y: int) from B to C;  @"y=x"  // (Intended) bad if replace above line -- fails assert-prog for C, C doesn't know x>=0
	3(z: int) from C to A;  @"z=y && z>=0"
}
//*/





/* // good.extensions.assrtcore.safety.unsat.AssrtCoreTest23
global protocol Proto1(role B, role A) @<x:="0">  // @<x:"x=0"> "x<10"
{
	//1(x: int) from A to B;  @"x > 1"
	5(Offer:int) from B to A;	 // Checking F updated properly (old Offer in F renamed)
	choice at A
	{
		hag() from A to B; @"(Offer>x)"  // Unsat check -- no explicit assert-prog check (to z3 -- squashed)
		do Proto1(B, A);   @<"Offer">
		//do Proto1(A, B);   @<"Offer">  // TODO CHECKME/FIXME: Offer in scopes at B, "duplicate" annot  -- current -assrt (should) forbids role-arg premut.?
	}
	or
	{
		sell() from A to B;
	}
}
//*/











/* // CHECKME: val forwarding, w.r.t. local K+F's
global protocol Proto1(role A, role B)  @<x := "1"> "x > 0"
{
	choice at A
	{
		1(y: int) from A to B;  @"y > 1"
		do Proto1(A, B);  @<"y">
	}
	or
	{
		2() from A to B;  // Testing rec-assrt check, input branch checks action based on enqueue message
	}
}
//*/


/*
// CHECKME: val forwarding, w.r.t. local K+F's
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;  @"x > 1"
	1(y: int) from B to C;  @"x = y"
}
//*/
















/*
global protocol Proto1(role A, role B, role C)
{
	1(x: int) from A to B;
	2(y: int) from A to C;
	do Proto1(A, B, C);  // Testing updateScopes, records *past* scopes (i.e., excluding current) in order
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	0() from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role A, role B, role C)
{
	IsAbove(v1:int) from A to B;  
	SecOut(r2:int) from A to C;  
			// Testing updateScopes model construction -- v1 can be dropped and re-sent before first r2 is picked (async recursion) -- increases state space
			// Tests updateScopes, non-initial self-recursion
	do Loop(A, B, C);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from A to B;
	do Loop(A, B, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  // Testing tarjan -- updateScopes explodes state space, three-party-interleaves async recursion with K/F-GC
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes
	2(y: int) from A to B;  @"y>x"
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"  // Testing updateScopes (always empty scopes)
	do Proto1(A, B);
}
//*/


















/* Test019 -- Test31, though a few bad tests omitted */

/*
global protocol Proto1(role A, role B) @"x>0"  // FIXME: unknown x -- also tested empty lhs for getRecAssertCheck
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	//do Proto1Aux(A, B);  // FIXME: do-sexpr WF -- CHECKME: or allow? (cf., below)
	do Proto1Aux(A, B);  @<"1">
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"  // Testing getRecAssertCheck lhs building
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	do Proto1(A, B);  @<"2">  // Testing svar initial and update values
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  @<"2">  // Testing "inlining" of do-sexpr args as rec-svar exprs by proto inlining
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1"> "x>0"
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  @<"2">  // FIXME: no target satate var
}

aux global protocol Proto1Aux(role A, role B)  //@"x>0"
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;	
	do Proto1Aux(A, B);  // TODO CHECKME: allow? (omitted state args)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	2() from B to A;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(y:int) from A to B;  @"y>1"  // TODO: testing F var renaming/compacting -- A async returns to rec-state while B still in "prev" iteration
	do Proto1(A, B);
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1(y:int) from A to B;  @"y>1"
	do Proto1(A, B);  @<"y">  // TODO: testing F var renaming/compacting and V/R renaming
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;
	2() from B to A;
	do Proto1(A, B);  @<"2"> 
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"2">
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;  // Testing removal of _dum1 : _Unit translation for empty payload -- reduces model size
	do Proto1(A, B);  @<"1">  // Testing .toTrueAssertion state exprs
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	// FIXME: unused role decls

	do Proto1(A, B);  @<"1">  // (But tested .toTrueAssertion state exprs)
}
//*/


/*
global protocol Proto1(role A, role B) @<x := "1">
{
	1() from A to B;	
	do Proto1(A, B);  // CHECKME: OK?
}
//*/





















/* Test001 -- Test018 */

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: AssrtCoreTest.int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"True"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x>0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"  // Testing whitespace
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"x > 0"  // Testing unknown var error
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x: int) from A to B;  @"x > 0"
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;  @"False"  // Testing assrt-prog
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{
		1() from A to B;  @"False"  // Testing assrt-unsat
	}
	or
	{
		2() from A to B;  @"True"
	}
}
//*/


/*
global protocol Proto1(role A, role B)  @"True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1"> "True"
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "1">
{
	1() from A to B;
}
//*/


/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto1(A, B);  // Testing base recursive do, inlining
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // Testing base f/w entry do with recursive do, inlining
}

aux global protocol Proto1Aux(role A, role B)
{
	1() from A to B;
	do Proto1Aux(A, B);
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  @<"0">  // TODO CHECKME: OK to f/w entry "override" default sexprs?  (depends if default sexprs are for "init" only or not)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)
{
	do Proto1Aux(A, B);  // TODO FIXME? conversely, OK to not supply sexprs?  (o/w rec statevar decl exprs only for root?)
}

aux global protocol Proto1Aux(role A, role B)  @<x := "1">
{
	1() from A to B;	
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	do Proto1(A, B);  @<"1">  // FIXME: A, B, not used
}
//*/


/*
global protocol Proto1(role A, role B)  @<x := "0">
{
	1() from A to B;
	do Proto1(A, B);  @<"1">
}
//*/



















/* // AssrtCoreTest4.scr
global protocol Proto1(role C, role S)
{
	HELLO(u:int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S; 
		ADD(v:int) from C to S; 
		RES(f:int) from S to C;
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role C, role S)
{
	HELLO(u:int) from C to S;
	choice at C
	{
		ADD(w:int) from C to S;  @"w > 0"
		ADD(v:int) from C to S;  @"v > 0"
		RES(f:int) from S to C;  @"f > 0"
		do Proto1(C, S);
	}
	or
	{
		BYE() from C to S;
		BYE() from S to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(int, int, int, int) from P to R;  // Currently same state space as below, due to "_dum" var names (and K/scopes)
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(int) from P to R;   
		Res(int) from R to P;
		IsAbove(int) from P to R;   
		Res(int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(int, int) from P to R;
			Res(int) from R to P;
			choice at P
			{
				SecOut(int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(int, int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;
		choice at P
		{
			BothIn() from P to R;
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  // unfoldScopes state space increase (async recursion with scopes resetting)
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role P, role R, role C)
{
	Plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

aux global protocol Loop(role P, role R, role C)
{
	choice at P
	{
		IsAbove(v1:int) from P to R;   
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		IsAbove(v2:int) from P to R;   
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P
		{
			BothIn() from P to R;  @"b1=1 && b2=1"
			BothIn(r1:int) from P to C;
			do Loop(P, R, C);
		}
		or
		{
			BothOut() from P to R;  @"b1=0 && b2=0"
			BothOut() from P to C;
			do Loop(P, R, C);
		}
		or
		{
			Intersct(y1:int, y2:int) from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)" // && y1=v1 && y2=v2
			Res(i:int) from R to P;
			choice at P
			{
				SecOut(r2:int) from P to C;  @"b2=0" // && r2=i
				do Loop(P, R, C);
			}
			or
			{
				SecIn(r3:int, r4:int) from P to C;  @"b2=1" //  && (r3=i && r4=v2)
				do Loop(P, R, C);
			}
		}
	}
	or
	{
		Close() from P to R;   
		Close() from P to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	NumberOne (x: int) from A to B;  //@"x > 3"
	NumberTwo (y: int) from B to C; @ "x = y"
	ReturnValueTwo (z: int) from C to B; @ "z = y + y"
	ReturnValueOne (t: int) from B to A; @ "t = z"
			// Testing what does A know about t -- A knows t=z, but not z = y+y   // CHECKME: OK for A to know "t" (K+F)?  should be sound
			// In general y could be from anywhere, and A won't know y's value
			// However, in this case y = x and x came from A -- CHECKME: refine?  or perhaps if z = x + x
}
//*/


/*  Cf. Fib.scr
global protocol Proto1(role C, role S)  @<x := "0", y := "1"> "y>0 && x>=0"
		//@"(x := 0, y := 1) y>0 && x>0"  // Bad initial Rass (and later unsat)
		//@"(x := 0, y := 1) (y>0))"
{
	choice at C
	{
		Val(x1:int) from C to S;  @"x1 = x"
		Add(y1:int) from C to S;  @"y1 = y"
		Sum(z:int) from S to C;   @"z = (x1+y1)"
		do Proto1(C, S);          @<"y1", "z">  // FIXME
	}
	or
	{
		Bye() from C to S;
	}
}
//*/















































/*
global protocol Proto1(role A, role B)
{
	//1(x:int) from A to B;  @"x>1 || (x>2 && x>3)"  // Testing CNF

	//1(x:int) from A to B;  @"(x>1 && x>2) || x>3"
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from A to B;  @"y=x+x && x=x"  // FIXME: combine multiple exprs into sigma conjunction
	2(y:int) from A to B;  @"y=x+x"
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B;  @"x>3"
	choice at A
	{
		2(int) from A to B;  @"x>5"

		//3(int) from A to C;  @"x>6"  // Bad  // TODO add as unit test
		3(int) from A to C;  @"x>4"  // OK
	}
	or
	{
		4(int) from A to B;
		5(int) from A to C;
	}
}
//*/



/*
global protocol P1(role A, role B, role C)
{
	1(x:int) from A to C;
	2(y:int) from B to C;  @"y>x"

	//2(y:int) from C to B;  @"y>x"  // FIXME: paper definition
}

global protocol P2(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	choice at B
	{
		2() from B to A;
	}
	or
	{
		3(y:int) from B to A; @"((y > (x + 1)) && y < 4)"
	}
}

global protocol P3(role A, role B, role C)
{
	1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; //@"(y<3 || y=3)"//"!(y=3)"//@"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"x > y"
	}
}
//*/



/*
global protocol Proto1(role A, role B, role C)
{
	/*1(x : int) from A to B; @"x > 3"
	choice at B
	{
		2() from B to A; @"True"
	}
	or
	{
		3(y : int) from B to A; @"((y > (x + 1)) && y < 4)"
	}*/
	
	/*1(x : int) from A to B; @"x > 3"
	2(y : int) from C to B; @"True"
	choice at B
	{
		3() from B to A; @"x < y"
	}
	or
	{
		4() from B to A; @"y > x"
	}* /
	
	1(x:int) from A to B;  @"x>3"
	2(y:int) from A to C;  @"y>x"




	/*0(z:int) from B to A;   @"(z>3)"
	choice at A
	{
		1(x:int) from A to B;   @"(x>3)"
	}
	or
	{
		2(y:int) from A to B;   @"(y>3)"
	}*/
		
	
	
	
	/*choice at B
	{
		2(y:int) from B to A;   @"y=x && y>3"
	}
	or
	{
		3(z:int) from B to A;   @"z=x && z<3"
	}* /
}
//*/


/*
assert f(x:int) bool = "x";  
		// Cannot be recursive as an assertion -- so not so useful for "explicit" code gen?  (vs. basic expr capturing) -- mainly use as "assertion code gen"?
		// Should only be for validation?

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	//2(y:int) from B to A;  @"y = f(x)"
	2(y:int) from B to A;
}
*/


/*
global protocol Proto1(role A, role B, role C) {
	choice at A
	{
		1() from A to B; @"A1"
		1() from A to C;           // CHECKME: receiver-side ass not projected -- but if it were, would need A1
	}
	or
	{
		...
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	do Loop(P, R, C);
}

global protocol Loop(role P, role R, role C) {
	choice at P {
		Above(v1:int) from P to R;   
		Res(b1:int) from R to P;  @"b1=0 || b1=1"
		Above(v2:int) from P to R;   
		Res(b2:int) from R to P;  @"b2=0 || b2=1"
		choice at P {
				BothIn() from P to R;  @"b1=1 && b2=1"
				BothIn(r1:int) from P to C;
				do Loop(P, R, C);  // Recursion
			} or {
				BothOut() from P to R;  @"b1=0 && b2=0"
				BothOut() from P to C;
				do Loop(P, R, C);  // Recursion
		} or {
			Intersect() from P to R;  @"(b1=1 && b2=0) || (b1=0 && b2=1)"
			Res(i:int) from R to P;
			choice at P {
				One(r2:int) from P to C;   @"b2=0 && r2=i"
				do Loop(P, R, C);  // Recursion
			} or {
				Two(r3:int, r4:int) from P to C;  @"b2=1 && (r3=i && r4=v2)"
				do Loop(P, R, C);  // Recursion
		} }
	} or {
		Close() from P to R;   
		Close() from P to C;  // End
	}
}
//*/


/*
global protocol SH(role P, role R, role C) {
	plane(x1:int, x2:int, x3:int, x4:int) from P to R;
	rec Loop {
		choice at P {
			check(p1:int, p2:int) from P to R;
			PointsToForward(res:int) from R to P; @"res>=0 && res<=2"
			choice at R {
				noIntersection() from R to P; @"res=1"
				OnePoint(v1:int) from P to C; @"v1=p2"
				continue Loop;
			} or {
				noPoints() from R to P; @"res=0"
				noPoints() from P to C;
				continue Loop; 
			} or {
				intersection(p3:int) from R to P; @"res=1 || res=2"
				choice at P {
					OnePointb(v2:int) from P to C; @"res=1 && v2=p3"
					continue Loop;
				} or {
					TwoPoint(v3:int, v4:int) from P to C; @"res=2 && (v3=p3 && v4=p2)"
					continue Loop;
				}
			}
		} or {
			Close() from P to R;
			Close() from P to C;
		}
	}
}
//*/



/*
global protocol Proto1(role A, role B)
{
	//1(x:int, y:int) from A to B;  @"x>3 && y>4"  // OK

	/*1(x:int, y:int) from A to B;  @"x=y"  // OK
	2() from B to A;  @"x=y"* /

	1(x:int, y:int) from A to B;
	2() from B to A;  @"x=y"  // Bad
}
//*/












/*
..demo:
- model building: model state extensions for assertions
-- assert-prog vs. sat -- DbC assert-prog choice case disjunction
-- bounded model with recursion (1): actvar renaming ("oldvar" GC) -- leveraging syntactic unfolding "semantics" of recursion
-- async MP: renaming following message flows
- statevars
-- bounded model with recursion (2): conservative forall on old statevars
-- "same var" special case
-- statevar invariants -- statevar-assert-prog
- uninterpreted funs
-- domain-specific theories (e.g., open/port)
-- encode roles/etc as ints
-- domain-specific API gen

global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"x>3"
	
	choice at B
	{
		2() from B to A;  @"x<0"
		4() from B to A;  @"False"
	}	
	or
	{
		3() from B to A;  @"True"
	}	
}
//*/


























/*
global protocol Proto1a(role A, role B)  @"(x:=1)"
{
	1(x:int) from A to B;	
	2(y:int) from B to A;	 @"y>x"

	do Proto1a(A, B);  @"<x+1>"
}

global protocol Proto1b(role A, role B)
{
	1() from A to B;	
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1c(role A, role B)
{
	1() from A to B;	     @"x>3"
	2(y:int) from B to A;	 @"y>x"
}

global protocol Proto1d(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"  // y>x added to F(C), but x *not* added to F(C) -- N.B. x will be forall quantified at C, and x>3 *not* in F(C) 
	3(z:int) from C to A;	 @"z>x"
}

global protocol Proto1e(role A, role B, role C)
{
	1(x:int) from A to B;	 @"x>3"
	2(y:int) from B to C;	 @"y>x"
	3(z:int) from A to C;	 @"z>x"  // assertion not checked on receiver side
}

global protocol Proto1f(role A, role B, role C, role D)
{
	1(x1:int) from A to B;	@"x1=3"
	2(x2:int) from A to D;	@"x2=x1"

	3(y1:int) from B to C;	@"y1=x1"
	4(y2:int) from D to C;	@"y2=x2"
	
	5(z:int) from C to A;   @"z=y1 && z=y2"  // only adding "immediate" assertion to F is weak? can strengthen?
}
//*/












/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;  @"!(x<3)"
	2() from A to B;  @"(True && !(False))"

}
//*/

/*
global protocol Proto1(role A, role B)
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B) @"2<3"  // FIXME: unknown vars check
{
	2() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B) @"(x:=(1+(1-1)), y:=4)"
{
	1() from A to B; @ "(x<3 && x<3) || x<3+(1+2)"
	//@"(((x>1) && (x>2)) && (x>3))"
	//@"(((True)))"
	2() from B to A; @"foo()"  // FIXME: constants
	//2() from B to A; @"((((True))))"
	do Proto1(A, B);  @"<0, 0>"
}
//*/



// TODO try: mu X . ( A->B 1 . X + A->B 2 . mu Y . A->B 3 . Y ) with statevars and assertions

/*
global protocol Proto1(role A, role B)
		@"(x := 1) (x>0)"
		//@"(x := 0) (x>0)"
{
	//1(y:int) from A to B; @"(y>1)"
	1() from A to B;
}
//*/

/*
global protocol Proto1(role A, role B)
{
	//1(y:int) from A to B; @"(y>1)"
	1(y:int) from A to B; @"(y>3)"
	do Proto2(A, B); @"(y)"
}

aux global protocol Proto2(role A, role B) @"(x := 0) (x>2)"
{
	2() from B to A;
}
//*/

/*
global protocol Proto1(role A, role B)  @"(x := 1)"
{
	1(y:int) from A to B;  @"(y > x)"
	2() from B to A;
	do Proto1(A, B);  @"(x)"
}
//*/

/*
global protocol Proto1(role A, role B)  
		@"(x := 3) (x>2)"
		//@"(x := 3) (x>0)"
		//@"(x := 3) (x>1)"
{
	1() from A to B; @"(x>1)"
	//2() from B to A;
	//do Proto1(A, B);  @"(x)"  
			// CHECKME: no longer needs to be special case, given appropriate rec-assertion? -- but at least is an optimisation?
			// no: special case still different, no "old var" renaming (no "inductive unrolling")
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

/*
//global protocol Proto1(role A, role B)  @"(x := 1)"
global protocol Proto1(role A, role B)  @"(x := 2) (x>1)"
//global protocol Proto1(role A, role B)  @"(x := 1) (y>0)"
{
	//1() from A to B;
	//1() from A to B; @"(x>0)"
	1() from A to B; @"(x>1)"
	2() from B to A;

	//do Proto1(A, B);  @"(x)"
	//do Proto1(A, B);  @"((x+1))"
	do Proto1(A, B);  @"((x-1))"
}
//*/

















// uninterpreted functions for custom API gen
// multi statvars -- fibo, linear
/*
global protocol Proto1(role A, role B) @"(x:=(0+3), y:=1)"
{
	1(z:int) from A to B;  @"(x>1)"
	do Proto1(A, B); @"(3, 1)"
}
//*/


/*
explicit global protocol Proto1(role A, role B, role C)
{
	connect A to B;
	1(lin x:int) from A to B; @port(x, C);  // implies port(x, C) and not(port(x, A)), not(port(x, B))
	
	rec X1 (used_x = 0) {

		1(z:int) from B to C; @(fw(x -> z) ... used_x =0); // implies port(x, C) and not(port(x, A)), not(port(x, B))
		
		rec X2 (used_x = 1) {

			1(z2:int) from B to C; @(... used_x = 0); // implies port(x, C) and not(port(x, A)), not(port(x, B))

			connect B to C;
			2(y:int) from B to A; @(x=y);

			connect C to A; @request(x, C);  // C should know x; should imply port(x, C);
		}
		}
} // terminal state needs all linear used
//*/


/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B; 
	2(y:int) from B to A; @(x=y);
	3(z:int) from B to A; @(z=y);  // Should this be "linearity" error?
}
//*/


























/*/
global protocol Proto1(role A, role B) @(x=0);
{
	1() from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2() from B to A; @(x<1);  // FIXME: shouldn't be in scope without decl as Proto2 statevar -- OK because aux? error caught if Proto2 checked as root
}
//*/

/*
global protocol Proto1(role B, role S)
{
	ok() from B to S;
	do Proto2(B, S); @Quote;  // FIXME: unknown vars check
}

global protocol Proto2(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);  // FIXME: unknown vars check here too?
}
//*/


/*
global protocol Proto1(role A, role B) @(z=3);
{
	1(x:int) from A to B; @(x=3);
	2(y:int) from A to B; @(y>x);
	do Proto1(A, B);  // FIXME: statevar arg check
}
//*/












/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	
	do Proto2(A, B); @(x);  
			// FIXME: need to make expr vars old in F? -- proto shouldn't be valid?
			// could rename target y to x in this case? relies on "globally" (across subprotos) unique vars -- cf. rolename substitution
}

// Not aux
global protocol Proto2(role A, role B) @(y=4);
{
	1() from A to B; @(y>2);	
	do Proto1(A, B); @(y);
}
//*/

/*
global protocol Proto1(role A, role B)
{
	do Proto2(A, B); @1;  
			// FIXME: in this case, consider subsituting the x in Proto1<x+1> like DbC? but would be inconsistent generally?
			// FIXME: at least consider case for substituting x if syntactically just "x" and still just x -- cf. bad.extensions.assrtcore.safety.assrtprog.statevar.AssrtCoreTest08b
}

global protocol Proto2(role A, role B) @(x=1);
{
	1(y:int) from A to B; @((y=x) && (x=1));

	//do Proto1(A, B); @1;
	do Proto2(A, B); @(x+1);  
			// Unsat -- cf. DbC? -- OK there? but relies on two-unfolding cut off? 
			// No: DbC subs the x in X<x+1> fixing it to two at two unfoldings and forever after? that's why safe there
			
	// FIXME: check tests for "loop counting", e.g., X<x+1> -- and also with lower bounded ints (do bounds manually)
}
//*/

/*
global protocol Proto1(role A, role B) @(x=3);
{
	1() from A to B; @(x>2);	

	//do Proto1(A, B); @x;  // Currently unsat -- cf. DbC? -- DbC it wouldn't be "x", it would "already" be 3 from substitution
			// Note, Proto1 could be called from "any context", so x can really be anything
			// FIXME: make sat? treat single var formula as special case? cf. equality in "non-local" assertions vs. gt/lt

	//do Proto1(A, B); @(x+1);  // Unsat
	do Proto1(A, B); @(x-1);  // Unsat -- should be unsat
}
//*/

/*
global protocol Proto1(role A, role B)
{
	1(x:int) from A to B;
	do Proto2(A, B);
}

aux global protocol Proto2(role A, role B)
{
	2(x:int) from B to A;  // FIXME: need proper var shadowing
}
//*/
















// ---


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // OK: B knows x

	//---

	1(x:int) from A to B; @(x>3);
	2() from B to C;
	3(y:int) from C to B; @(y>x);  // Bad: C doesn't know x -- though it knows x > 3 -- FIXME: how to disallow this? but still allow the below
			// CHECKME: DbC -- cf. HS
	
	//---	
	
	1(x:int) from A to B; @(x=3);  // FIXME: but equality should be strong enough?
	2() from B to C;
	3(y:int) from C to B; @(y>x);
}
//*/


/*
global protocol Proto1(role A, role B) @(z=0);
{
	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // C does *not* "know" x -- but knows constraints must be satisfied up to here
	3(z:int) from C to D; @(z>y);
	
//--- vs.

	1(x:int) from A to B; @(x=3);  // equality is "precise" enough for "strong path inference"
	2(y:int) from B to C; @(y>x);
	3(z:int) from C to D; @(z>y);
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	1(x:int) from A to B; @(x>1);
	2(y:int) from B to C; @(y>x);

	//3(z:int) from C to A; @(z=y);  // OK
	3(z:int) from C to A; @((z=y)&&(y>x));  //  Morally same as above -- given C should know this from the "path" here
			// FIXME? C doesn't know x -- but could pass prev assertions along with current? cf. DbC projection (at receiver)
			// DbC projection vs. HS/TS? -- DbC receive-exists projection vs HS/TS "forall"?
}
//*/



















/*
global protocol Proto1(role A, role B, role C)
{
	// testing "passing" rename (shadow) map with messages -- also need to test re-receiving rename map with already applied renaming

	1(x:int) from A to B; @(x>3);
	2(y:int) from B to C; @(y>x);  // compacting doesn't terminate -- FIXME: F renaming needs to be done based on K? i.e., also rename x in F(C)?
	//3(z:int) from C to D; @(z>x);  // ... FIXME: but what if C uses x again in upcoming assertions after the renaming? -- hence pass the renaming as a message
			// -- keep a ("one-level"?) rename map? -- cf. rec unfolding with rec-annotation substitution
			// -- no: C can't use x as a sender, not known; but how about as receiver?
			// -- should renamed vars be recorded in K?
	//3(z:int) from B to C; @(z>x);
	do Proto1(A, B, C);
}
//*/




























































// --- ???


/*
global protocol JavaSmtBug(role B, role S) @(x=0);
{
	5() from B to S;	@False;//@(y>0);
	do JavaSmtBug(B, S); @x;  // Cf. AssrtExistsFormula::toJavaSmtFormula comments
}
//*/


/*
global protocol Proto1(role A, role B) @(x=3);
{
	choice at A
	{
		1(int) from A to B;
		do Proto1(A, B); @4;
	}
	or
	{
		2(int) from A to B;
		do Proto1(A, B); @3;
	}	

		//1(y:int) from A to B; @(x=4);

		//1(y:int) from A to B; @((y=4) && (x=y));
		
		//1(y:int) from A to B; @(x=y);


		//do Proto1(A, B); @3;
}
//*/


/*
global protocol Proto1(role A, role B, role C)
{
	choice at A
	{	
		1(int) from A to B;
		4(int) from A to C;
	}
	or
	{
		2(int) from A to B;
		3(int) from A to C;
	}
}
//*/


/*
global protocol Proto1(role A, role B)
{
	choice at A
	{	
		1(x:int) from A to B;
		choice at A
		{
			2(y:int) from A to B;
			do Proto1(A, B);
		}
		or
		{
			3(z:int) from A to B;
		}
	
	}
	or
	{
		2(int) from A to B;
	}
}
//*/

